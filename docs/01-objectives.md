# Rust Expert | AI LLM

## Objectives and justifications.

The main objective is to create a model that is adept at answering questions, providing feedback, and generating code in Rust. This is done in a professional, accurate, and efficient manner.

The development of this model will be progressive; this means that it will start out basic and inefficient but will become more efficient and precise with each iteration.

### What sets this model apart from others?

First, I want the code it generates to be 100% executable. Currently, models sometimes send code that can only be compiled because it has so many errors. This requires developers to invest large amounts of time and effort trying to fix the code and see if it's what they expect. That's why it's a significant value proposition that 99.99% of the code generated by this model is executable, even if it's initially simple.

Second, I want the developer to be a true expert in Rust. I want the system to be kept from being complex and convoluted, constantly striving for practicality and simplicity. Basically, I want it to follow the SOLID principles of software development.

Part of the ambitious goals is to be able to build an extremely complex system with minimal errors when generating the code, which can ultimately be corrected to compile and run in production.

### Roadmap.

To see the roadmap visit the page [02 Roadmap](02-roadmap.md).

### Planning MVP releases

The model's development will follow a progressive, multi-stage MVP release plan. Each stage builds upon the last, ensuring a solid foundation before moving to more complex features. The core principle is that all generated code must be 100% executable and idiomatic.

1. **MVP 0.1: Core Concepts**
   * **Goal:** Generate basic, single-file Rust programs that are guaranteed to compile and run.
   * **Features:**
     * `main` function with fundamental control flow (`if`, `else`, `for`, `while`).
     * Basic data types (integers, floats, booleans, strings, tuples, arrays).
     * Variable declaration (`let`, `mut`).
     * Generation of a minimal `Cargo.toml` and `cargo run` instructions.

2. **MVP 0.2: Code Organization**
   * **Goal:** Introduce structured and reusable code.
   * **Features:**
     * Refactor logic into functions with parameters and return values.
     * Organize code into multiple files using the module system (`mod`).
     * Introduce basic error handling with `Option` and `Result`.

3. **MVP 0.3: Data Modeling**
   * **Goal:** Define and manage complex data structures.
   * **Features:**
     * Define and instantiate `structs` and `enums`.
     * Implement methods and associated functions in `impl` blocks.

4. **MVP 0.4: Abstraction**
   * **Goal:** Implement polymorphism and generic, reusable code.
   * **Features:**
     * Define and implement `traits`.
     * Use generics with functions, structs, and traits.
     * Utilize common standard library traits (e.g., `Debug`, `Clone`, `Copy`).

5. **MVP 0.5: Ecosystem Integration**
   * **Goal:** Interact with the broader Rust ecosystem.
   * **Features:**
       * Add and manage external crates in `Cargo.toml`.
       * Use items from third-party libraries (e.g., `serde`, `rand`, `regex`).

6. **MVP 0.6: Advanced Features**
   * **Goal:** Handle concurrency and other advanced Rust capabilities.
   * **Features:**
       * Safe concurrency using `std::thread`, channels (`mpsc`), `Arc`, and `Mutex`.
       * (Cautiously) generate `unsafe` code for well-defined use cases like FFI, with clear explanations.
       * Generate basic declarative macros (`macro_rules!`).

7. **MVP 0.7: Real-Time Knowledge**
   * **Goal:** Provide up-to-date, contextually aware answers and code.
   * **Features:**
       * Integrate Retrieval-Augmented Generation (RAG) to access the latest Rust documentation, crate information, and community best practices.
       * Answer questions about recent language features and provide crate recommendations based on fresh data.

### Dataset objectives.

1. Generate a good repository of training data (SFT dataset) for use in this or other projects.

### Experiment objectives.

1. Perform supervised fine-tuning (SFT) 10 times for the same base model. The goal is to validate whether, despite the same base model and input data, it generates different weights, creating a very different model, or ultimately generates the same models.
2. Use different base models in terms of companies, parameter sizes, and model type to perform supervised fine-tuning (SFT) and investigate which one is best for testing.
