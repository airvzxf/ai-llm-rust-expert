# Rust Expert | AI LLM

## Objectives and justifications.

The main objective is to create a model that is adept at answering questions, providing feedback, and generating code in Rust. This is done in a professional, accurate, and efficient manner.

The development of this model will be progressive; this means that it will start out basic and inefficient but will become more efficient and precise with each iteration.

### What sets this model apart from others?

First, I want the code it generates to be 100% executable. Currently, models sometimes send code that can only be compiled because it has so many errors. This requires developers to invest large amounts of time and effort trying to fix the code and see if it's what they expect. That's why it's a significant value proposition that 99.99% of the code generated by this model is executable, even if it's initially simple.

Second, I want the developer to be a true expert in Rust. I want the system to be kept from being complex and convoluted, constantly striving for practicality and simplicity. Basically, I want it to follow the SOLID principles of software development.

Part of the ambitious goals is to be able to build an extremely complex system with minimal errors when generating the code, which can ultimately be corrected to compile and run in production.

### Roadmap.

To see the roadmap visit the page [02 Roadmap](02-roadmap.md).

### Planning MVP releases
1. The model creates code in basic Rust: it uses if, else, else if, for, and while statements in the “main” function. It also uses “Cargo.toml” and execution instructions. All generated code must run without any problems.
2. Create functions to organize the code.
3. Use modules to organize the code.
4. Use traits to organize the code.
5. Use crates in the proyect.
6. [Further objectives pending].

### Dataset objectives.

1. Generate a good repository of training data (SFT dataset) for use in this or other projects.

### Experiment objectives.

1. Perform supervised fine-tuning (SFT) 10 times for the same base model. The goal is to validate whether, despite the same base model and input data, it generates different weights, creating a very different model, or ultimately generates the same models.
2. Use different base models in terms of companies, parameter sizes, and model type to perform supervised fine-tuning (SFT) and investigate which one is best for testing.
